#!/bin/bash
set -euo pipefail
# Enable extended globbing for pattern trims like +([[:space:]])
shopt -s extglob

cd "$(dirname "$0")"

# Configurable behavior
# When set to 1, identical files in $HOME will be replaced with symlinks to this repo
RELINK_IDENTICAL="${SETUP_RELINK_IDENTICAL:-0}"

# Optional: update external repos that already exist and match manifest
UPDATE_EXTERNAL="${SETUP_UPDATE_EXTERNAL:-0}"

# Private dotfiles submodule path
PRIVATE_REPO_PATH="$(pwd)/dotfiles-private"

# Helpers
normalize_git_url() {
  local url="$1"
  [[ -z "$url" ]] && { echo ""; return; }
  echo "$url" \
    | sed -E 's#^git@([^:]+):#\1/#' \
    | sed -E 's#^https?://##' \
    | sed -E 's#\.git$##' \
    | sed -E 's#/*$##'
}

# Collect dotfiles from main repo (exclude common entries) and honor .gitignore
dot_items=()
while IFS= read -r -d '' path; do
  rel="${path#./}"
  # Skip Git-ignored files if inside a Git work tree and the path is ignored
  if command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    if git check-ignore -q -- "$rel"; then
      continue
    fi
  fi
  dot_items+=("$path")
done < <(find . -maxdepth 1 -mindepth 1 -name '.*' \
  ! -name '.' ! -name '..' ! -name '.git' -print0)

# Collect dotfiles from private repo if it exists
private_dot_items=()
if [[ -d "$PRIVATE_REPO_PATH" ]]; then
  while IFS= read -r -d '' path; do
    rel="${path#$PRIVATE_REPO_PATH/}"
    private_dot_items+=("$path")
  done < <(find "$PRIVATE_REPO_PATH" -maxdepth 1 -mindepth 1 -name '.*' \
    ! -name '.' ! -name '..' ! -name '.git' -print0)
fi

# Preflight: ensure no destination files or links already exist
conflicting_files=()
conflicting_links=()
items_to_link=()
already_linked_symlinks=()

# Detailed conflict buckets for files
identical_file_conflicts=()
identical_pairs_to_relink=() # store src::dest for identical files to relink when RELINK_IDENTICAL=1
different_file_conflict_pairs=() # store src::dest for later diff output
dir_conflicts=()
# Config directory special handling
config_items_to_link=()
config_conflicts=()
config_already_linked=()

# Private repo tracking
private_items_to_link=()
private_config_items_to_link=()
private_conflicts=()
private_config_conflicts=()
private_already_linked=()
private_config_already_linked=()

# External repos manifest (lines of: relative/path|git_url|optional_branch)
external_to_clone=()
external_conflicts=()
external_present_ok=()

# Read external repo manifest if present
if [[ -f external_repos.txt ]]; then
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    IFS='|' read -r rel_path repo_url branch <<< "$line"
    dest="$HOME/$rel_path"
    if [[ -e "$dest" || -L "$dest" ]]; then
      # If a git repo exists at destination and remote matches, reuse it
      if [[ -d "$dest/.git" ]]; then
        manifest_norm=$(normalize_git_url "$repo_url")
        origin_url=$(git -C "$dest" remote get-url origin 2>/dev/null || echo "")
        origin_norm=$(normalize_git_url "$origin_url")
        if [[ -n "$manifest_norm" && "$manifest_norm" == "$origin_norm" ]]; then
          external_present_ok+=("$dest::$branch")
        else
          external_conflicts+=("$dest")
        fi
      else
        external_conflicts+=("$dest")
      fi
    else
      external_to_clone+=("$repo_url::$dest::$branch")
    fi
  done < external_repos.txt
fi

# Process main repo dotfiles
for path in "${dot_items[@]}"; do
  item="${path#./}"
  src="$(pwd)/$item"
  dest="$HOME/$item"

  # Special handling for .config directory
  if [[ "$item" == ".config" ]]; then
    # Handle .config directory contents individually
    if [[ -d "$src" ]]; then
      # Ensure $HOME/.config exists
      mkdir -p "$HOME/.config"
      
      # Build list of external repo paths that start with .config/
      external_config_paths=()
      if [[ -f external_repos.txt ]]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
          [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
          IFS='|' read -r rel_path repo_url branch <<< "$line"
          if [[ "$rel_path" == .config/* ]]; then
            config_subpath="${rel_path#.config/}"
            external_config_paths+=("$config_subpath")
          fi
        done < external_repos.txt
      fi
      
      # Process each directory in .config (skip files)
      while IFS= read -r -d '' config_path; do
        config_item="${config_path#$src/}"
        config_src="$src/$config_item"
        config_dest="$HOME/.config/$config_item"
        
        # Only process directories, skip files
        if [[ ! -d "$config_src" ]]; then
          continue
        fi
        
        # Skip items that are managed by external repos
        is_external=0
        if (( ${#external_config_paths[@]} > 0 )); then
          for external_path in "${external_config_paths[@]}"; do
            if [[ "$config_item" == "$external_path" ]]; then
              is_external=1
              break
            fi
          done
        fi
        
        if (( is_external == 1 )); then
          continue
        fi
        
        if [[ -L "$config_dest" ]]; then
          if [[ "$config_dest" -ef "$config_src" ]]; then
            config_already_linked+=("$config_dest")
          else
            config_conflicts+=("$config_dest")
          fi
        elif [[ -e "$config_dest" ]]; then
          config_conflicts+=("$config_dest")
        else
          config_items_to_link+=("$config_item")
        fi
      done < <(find "$src" -maxdepth 1 -mindepth 1 -print0)
    fi
  else
    # Regular dotfile handling for non-.config items
    if [[ -L "$dest" ]]; then
      if [[ "$dest" -ef "$src" ]]; then
        already_linked_symlinks+=("$dest")
      else
        conflicting_links+=("$dest")
      fi
    elif [[ -e "$dest" ]]; then
      # Classify regular files vs directories and check content differences for files
      if [[ -f "$dest" && -f "$src" ]]; then
        if diff -q "$dest" "$src" >/dev/null 2>&1; then
          if (( RELINK_IDENTICAL == 1 )); then
            identical_pairs_to_relink+=("$src::$dest")
          else
            identical_file_conflicts+=("$dest")
          fi
        else
          different_file_conflict_pairs+=("$src::$dest")
        fi
      elif [[ -d "$dest" && -d "$src" ]]; then
        dir_conflicts+=("$dest")
      else
        # Mixed types or other special files
        conflicting_files+=("$dest")
      fi
    else
      items_to_link+=("$item")
    fi
  fi
done

# Process private repo dotfiles if they exist
if (( ${#private_dot_items[@]} > 0 )); then
  for path in "${private_dot_items[@]}"; do
    item="${path#$PRIVATE_REPO_PATH/}"
    src="$path"
    dest="$HOME/$item"

    # Special handling for .config directory from private repo
    if [[ "$item" == ".config" ]]; then
      # Handle .config directory contents individually
      if [[ -d "$src" ]]; then
        # Ensure $HOME/.config exists
        mkdir -p "$HOME/.config"
        
        # Process each directory in private .config (skip files)
        while IFS= read -r -d '' config_path; do
          config_item="${config_path#$src/}"
          config_src="$src/$config_item"
          config_dest="$HOME/.config/$config_item"
          
          # Only process directories, skip files
          if [[ ! -d "$config_src" ]]; then
            continue
          fi
          
          if [[ -L "$config_dest" ]]; then
            if [[ "$config_dest" -ef "$config_src" ]]; then
              private_config_already_linked+=("$config_dest")
            else
              private_config_conflicts+=("$config_dest")
            fi
          elif [[ -e "$config_dest" ]]; then
            private_config_conflicts+=("$config_dest")
          else
            private_config_items_to_link+=("$config_item")
          fi
        done < <(find "$src" -maxdepth 1 -mindepth 1 -print0)
      fi
    else
      # Regular dotfile handling for non-.config items from private repo
      if [[ -L "$dest" ]]; then
        if [[ "$dest" -ef "$src" ]]; then
          private_already_linked+=("$dest")
        else
          private_conflicts+=("$dest")
        fi
      elif [[ -e "$dest" ]]; then
        private_conflicts+=("$dest")
      else
        private_items_to_link+=("$item")
      fi
    fi
  done
fi

BREWFILE_PATH="$(pwd)/Brewfile"

# If a Brewfile exists, perform a dry check to surface obvious issues early (non-fatal)
if [[ -f "$BREWFILE_PATH" ]]; then
  set +e
  brew bundle check --no-upgrade --file="$BREWFILE_PATH" >/dev/null 2>&1
  set -e
fi

if (( ${#conflicting_files[@]} > 0 || ${#dir_conflicts[@]} > 0 || ${#different_file_conflict_pairs[@]} > 0 || ${#conflicting_links[@]} > 0 || ${#external_conflicts[@]} > 0 || ${#identical_file_conflicts[@]} > 0 || ${#config_conflicts[@]} > 0 || ${#private_conflicts[@]} > 0 || ${#private_config_conflicts[@]} > 0 )); then
  echo "Refusing to proceed due to preflight problems:"
  if (( ${#identical_file_conflicts[@]} > 0 )); then
    echo "  Existing files with identical content (safe to remove and re-run):"
    printf '    %s\n' "${identical_file_conflicts[@]}"
  fi
  if (( ${#different_file_conflict_pairs[@]} > 0 )); then
    echo "  Files with content differences:"
    for pair in "${different_file_conflict_pairs[@]}"; do
      src_path="${pair%%::*}"
      dest_path="${pair##*::}"
      echo "    $dest_path"
    done
  fi
  if (( ${#dir_conflicts[@]} > 0 )); then
    echo "  Existing directories that would be overwritten:"
    printf '    %s\n' "${dir_conflicts[@]}"
  fi
  if (( ${#conflicting_files[@]} > 0 )); then
    echo "  Other conflicting paths:"
    printf '    %s\n' "${conflicting_files[@]}"
  fi
  if (( ${#conflicting_links[@]} > 0 )); then
    echo "  Existing symlinks present:"
    printf '    %s\n' "${conflicting_links[@]}"
  fi
  if (( ${#config_conflicts[@]} > 0 )); then
    echo "  Conflicting .config items (already exist):"
    printf '    %s\n' "${config_conflicts[@]}"
  fi
  if (( ${#external_conflicts[@]} > 0 )); then
    echo "  Conflicting destinations for external repos (already exist):"
    printf '    %s\n' "${external_conflicts[@]}"
  fi
  if (( ${#private_conflicts[@]} > 0 )); then
    echo "  Conflicting private repo items (already exist):"
    printf '    %s\n' "${private_conflicts[@]}"
  fi
  if (( ${#private_config_conflicts[@]} > 0 )); then
    echo "  Conflicting private .config items (already exist):"
    printf '    %s\n' "${private_config_conflicts[@]}"
  fi

  # Show unified diffs for differing files (truncate to first 500 lines for readability)
  if (( ${#different_file_conflict_pairs[@]} > 0 )); then
    echo
    echo "Diffs (destination vs repo version, first 500 lines):"
    for pair in "${different_file_conflict_pairs[@]}"; do
      src_path="${pair%%::*}"
      dest_path="${pair##*::}"
      echo "---- $dest_path ----"
      if command -v colordiff >/dev/null 2>&1; then
        colordiff -u "$dest_path" "$src_path" | sed -n '1,500p' || true
      else
        diff -u "$dest_path" "$src_path" | sed -n '1,500p' || true
      fi
      echo
    done
  fi
  echo "Abort. Resolve the above and re-run. Nothing was changed."
  exit 1
fi

# Transactional bookkeeping and rollback handler
created_links=()
created_dirs=()
installed_formulas=()
installed_casks=()
rollback_needed=0
backups_made=() # store dest::backup_path for relinked files

on_exit() {
  status=$?
  if (( status != 0 )) && (( rollback_needed == 1 )); then
    # Avoid nounset errors if arrays are empty or unset
    set +u
    if (( ${#created_links[@]} > 0 )); then
      echo "Rolling back created symlinks..."
      for link_path in "${created_links[@]}"; do
        rm -f "$link_path" || true
      done
    fi
    if (( ${#created_dirs[@]} > 0 )); then
      echo "Rolling back created directories..."
      for dir_path in "${created_dirs[@]}"; do
        rm -rf "$dir_path" || true
      done
    fi
    if (( ${#backups_made[@]} > 0 )); then
      echo "Restoring backups for relinked files..."
      for pair in "${backups_made[@]}"; do
        restore_dest="${pair%%::*}"
        backup_path="${pair##*::}"
        rm -f "$restore_dest" 2>/dev/null || true
        mv "$backup_path" "$restore_dest" 2>/dev/null || true
      done
    fi
    # (removed) Deprecated .config rollback
    # Best-effort rollback of Homebrew installs made during this run
    if [[ ${installed_casks+set} == set ]]; then
      for pkg in "${installed_casks[@]}"; do
        brew uninstall --cask "$pkg" >/dev/null 2>&1 || true
      done
    fi
    if [[ ${installed_formulas+set} == set ]]; then
      for pkg in "${installed_formulas[@]}"; do
        brew uninstall "$pkg" >/dev/null 2>&1 || true
      done
    fi
    set -u
  fi
}
trap 'on_exit' EXIT
rollback_needed=1

# Informational: already-correct symlinks
if (( ${#already_linked_symlinks[@]} > 0 )); then
  echo "Already linked (correct symlinks present):"
  printf '  %s\n' "${already_linked_symlinks[@]}"
fi

# Informational: already-correct .config symlinks
if (( ${#config_already_linked[@]} > 0 )); then
  echo "Already linked .config items (correct symlinks present):"
  printf '  %s\n' "${config_already_linked[@]}"
fi

# Informational: already-correct private symlinks
if (( ${#private_already_linked[@]} > 0 )); then
  echo "Already linked private items (correct symlinks present):"
  printf '  %s\n' "${private_already_linked[@]}"
fi

# Informational: already-correct private .config symlinks
if (( ${#private_config_already_linked[@]} > 0 )); then
  echo "Already linked private .config items (correct symlinks present):"
  printf '  %s\n' "${private_config_already_linked[@]}"
fi

# Informational: external repos already present and matching manifest
if (( ${#external_present_ok[@]} > 0 )); then
  echo "External repos already present and matching manifest (reusing):"
  for spec in "${external_present_ok[@]}"; do
    dest_dir="${spec%%::*}"
    branch="${spec##*::}"
    display_path="${dest_dir#$HOME/}"
    echo "  $display_path"
    if (( UPDATE_EXTERNAL == 1 )); then
      set +e
      git -C "$dest_dir" fetch --all --prune >/dev/null 2>&1
      if [[ -n "$branch" ]]; then
        git -C "$dest_dir" checkout -q "$branch" >/dev/null 2>&1
      fi
      git -C "$dest_dir" pull --ff-only >/dev/null 2>&1
      set -e
    fi
  done
fi

# Relink identical files if requested (RELINK_IDENTICAL=1)
if (( ${#identical_pairs_to_relink[@]} > 0 )); then
  for pair in "${identical_pairs_to_relink[@]}"; do
    src_path="${pair%%::*}"
    dest_path="${pair##*::}"
    display_path="${dest_path#$HOME/}"
    backup_path="${dest_path}.setup.bak.$$"
    echo "relinking $display_path (identical)..."
    mv "$dest_path" "$backup_path"
    ln -s "$src_path" "$dest_path"
    created_links+=("$dest_path")
    backups_made+=("$dest_path::$backup_path")
  done
fi

# Create all symlinks (only runs if preflight passed)
if [[ ${items_to_link+set} == set ]] && (( ${#items_to_link[@]} > 0 )); then
  for item in "${items_to_link[@]}"; do
    src="$(pwd)/$item"
    dest="$HOME/$item"
    echo "linking $item..."
    ln -s "$src" "$dest"
    created_links+=("$dest")
  done
fi

# Create .config symlinks
if [[ ${config_items_to_link+set} == set ]] && (( ${#config_items_to_link[@]} > 0 )); then
  for config_item in "${config_items_to_link[@]}"; do
    config_src="$(pwd)/.config/$config_item"
    config_dest="$HOME/.config/$config_item"
    echo "linking .config/$config_item..."
    ln -s "$config_src" "$config_dest"
    created_links+=("$config_dest")
  done
fi

# Create private repo symlinks
if [[ ${private_items_to_link+set} == set ]] && (( ${#private_items_to_link[@]} > 0 )); then
  for item in "${private_items_to_link[@]}"; do
    src="$PRIVATE_REPO_PATH/$item"
    dest="$HOME/$item"
    echo "linking private $item..."
    ln -s "$src" "$dest"
    created_links+=("$dest")
  done
fi

# Create private .config symlinks
if [[ ${private_config_items_to_link+set} == set ]] && (( ${#private_config_items_to_link[@]} > 0 )); then
  for config_item in "${private_config_items_to_link[@]}"; do
    config_src="$PRIVATE_REPO_PATH/.config/$config_item"
    config_dest="$HOME/.config/$config_item"
    echo "linking private .config/$config_item..."
    ln -s "$config_src" "$config_dest"
    created_links+=("$config_dest")
  done
fi

# Clone external repos, if any
if (( ${#external_to_clone[@]} > 0 )); then
  for spec in "${external_to_clone[@]}"; do
    repo="${spec%%::*}"
    rest="${spec#*::}"
    dest_repo="${rest%%::*}"
    branch="${rest##*::}"
    mkdir -p "$(dirname "$dest_repo")"
    display_path="${dest_repo#$HOME/}"
    if [[ -n "$branch" ]]; then
      echo "cloning $repo (branch $branch) -> $display_path..."
      git clone --depth 1 --branch "$branch" "$repo" "$dest_repo"
    else
      echo "cloning $repo -> $display_path..."
      git clone --depth 1 "$repo" "$dest_repo"
    fi
    created_dirs+=("$dest_repo")
  done
fi

if [[ -f "$BREWFILE_PATH" ]]; then
  echo "Running brew bundle from Brewfile..."
  # Snapshot pre-state
  formulas_before=( $(brew list --formula -1 2>/dev/null || true) )
  casks_before=( $(brew list --cask -1 2>/dev/null || true) )

  set +e
  bundle_output=$(brew bundle install --no-upgrade --file="$BREWFILE_PATH" 2>&1)
  bundle_status=$?
  set -e
  if (( bundle_status != 0 )); then
    echo "$bundle_output"
    # Determine what changed and schedule rollback
    formulas_after=( $(brew list --formula -1 2>/dev/null || true) )
    casks_after=( $(brew list --cask -1 2>/dev/null || true) )
    # Compute diffs (after - before)
    for pkg in "${formulas_after[@]}"; do
      present_before=0
      for b in "${formulas_before[@]}"; do
        if [[ "$b" == "$pkg" ]]; then present_before=1; break; fi
      done
      if (( present_before == 0 )); then installed_formulas+=("$pkg"); fi
    done
    for pkg in "${casks_after[@]}"; do
      present_before=0
      for b in "${casks_before[@]}"; do
        if [[ "$b" == "$pkg" ]]; then present_before=1; break; fi
      done
      if (( present_before == 0 )); then installed_casks+=("$pkg"); fi
    done
    exit $bundle_status
  fi
else
  echo "No Brewfile found; skipping Homebrew installs."
fi

# Success: allow normal exit; on_exit will detect status 0 and do nothing
# Clean up backups created during relink since we succeeded
if (( ${#backups_made[@]} > 0 )); then
  for pair in "${backups_made[@]}"; do
    backup_path="${pair##*::}"
    rm -f "$backup_path" 2>/dev/null || true
  done
fi
