#!/bin/bash
set -euo pipefail
# Enable extended globbing for pattern trims like +([[:space:]])
shopt -s extglob

cd "$(dirname "$0")"

# Configurable behavior
# When set to 1, identical files in $HOME will be replaced with symlinks to this repo
RELINK_IDENTICAL="${SETUP_RELINK_IDENTICAL:-0}"

# Optional: update external repos that already exist and match manifest
UPDATE_EXTERNAL="${SETUP_UPDATE_EXTERNAL:-1}"

# Brew package selection (macOS only)
BREW_PROFILE="${SETUP_BREW_PROFILE:-essentials}"
BREWFILE_OVERRIDE="${SETUP_BREWFILE:-}"
BREW_SUDO="${SETUP_BREW_SUDO:-1}"

# Private dotfiles submodule path
PRIVATE_REPO_PATH="$(pwd)/dotfiles-private"

# Helpers
normalize_git_url() {
  local url="$1"
  [[ -z "$url" ]] && { echo ""; return; }
  echo "$url" \
    | sed -E 's#^git@([^:]+):#\1/#' \
    | sed -E 's#^https?://##' \
    | sed -E 's#^git::@##' \
    | sed -E 's#\.git$##' \
    | sed -E 's#/*$##'
}

# Collect dotfiles from main repo (exclude common entries) and honor .gitignore
dot_items=()
while IFS= read -r -d '' path; do
  rel="${path#./}"
  # Skip Git-ignored files if inside a Git work tree and the path is ignored
  if command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    if git check-ignore -q -- "$rel"; then
      continue
    fi
  fi
  dot_items+=("$path")
done < <(find . -maxdepth 1 -mindepth 1 -name '.*' \
  ! -name '.' ! -name '..' ! -name '.git' -print0)

# Preflight: ensure no destination files or links already exist
conflicting_files=()
conflicting_links=()
items_to_link=()
already_linked_symlinks=()

# Detailed conflict buckets for files
identical_file_conflicts=()
identical_pairs_to_relink=() # store src::dest for identical files to relink when RELINK_IDENTICAL=1
different_file_conflict_pairs=() # store src::dest for later diff output
dir_conflicts=()
# Config directory special handling
config_items_to_link=()
config_conflicts=()
config_already_linked=()

# External repos manifest (lines of: relative/path|git_url|optional_branch)
external_to_clone=()
external_conflicts=()
external_present_ok=()
external_to_clean=()

# Read external repo manifest if present
if [[ -f external_repos.txt ]]; then
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    IFS='|' read -r rel_path repo_url branch <<< "$line"
    dest="$HOME/$rel_path"
    if [[ -e "$dest" || -L "$dest" ]]; then
      # If a git repo exists at destination and remote matches, reuse it
      if [[ -d "$dest/.git" ]]; then
        manifest_norm=$(normalize_git_url "$repo_url")
        origin_url=$(git -C "$dest" remote get-url origin 2>/dev/null || echo "")
        origin_norm=$(normalize_git_url "$origin_url")
        if [[ -n "$manifest_norm" && "$manifest_norm" == "$origin_norm" ]]; then
          external_present_ok+=("$dest::$branch")
        else
          external_conflicts+=("$dest")
        fi
      else
        # Incomplete/invalid directory - mark for cleanup
        external_to_clean+=("$dest")
        external_to_clone+=("$repo_url::$dest::$branch")
      fi
    else
      external_to_clone+=("$repo_url::$dest::$branch")
    fi
  done < external_repos.txt
fi

# Process main repo dotfiles
for path in "${dot_items[@]}"; do
  item="${path#./}"
  src="$(pwd)/$item"
  dest="$HOME/$item"

  # Special handling for .config directory
  if [[ "$item" == ".config" ]]; then
    # Handle .config directory contents individually
    if [[ -d "$src" ]]; then
      # Ensure $HOME/.config exists
      mkdir -p "$HOME/.config"
      
      # Build list of external repo paths that start with .config/
      external_config_paths=()
      if [[ -f external_repos.txt ]]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
          [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
          IFS='|' read -r rel_path repo_url branch <<< "$line"
          if [[ "$rel_path" == .config/* ]]; then
            config_subpath="${rel_path#.config/}"
            external_config_paths+=("$config_subpath")
          fi
        done < external_repos.txt
      fi
      
      # Process each directory in .config (skip files)
      while IFS= read -r -d '' config_path; do
        config_item="${config_path#$src/}"
        config_src="$src/$config_item"
        config_dest="$HOME/.config/$config_item"
        
        # Only process directories, skip files
        if [[ ! -d "$config_src" ]]; then
          continue
        fi
        
        # Skip items that are managed by external repos
        is_external=0
        if (( ${#external_config_paths[@]} > 0 )); then
          for external_path in "${external_config_paths[@]}"; do
            if [[ "$config_item" == "$external_path" ]]; then
              is_external=1
              break
            fi
          done
        fi
        
        if (( is_external == 1 )); then
          continue
        fi
        
        if [[ -L "$config_dest" ]]; then
          if [[ "$config_dest" -ef "$config_src" ]]; then
            config_already_linked+=("$config_dest")
          else
            config_conflicts+=("$config_dest")
          fi
        elif [[ -e "$config_dest" ]]; then
          config_conflicts+=("$config_dest")
        else
          config_items_to_link+=("$config_item")
        fi
      done < <(find "$src" -maxdepth 1 -mindepth 1 -print0)
    fi
  else
    # Regular dotfile handling for non-.config items
    if [[ -L "$dest" ]]; then
      if [[ "$dest" -ef "$src" ]]; then
        already_linked_symlinks+=("$dest")
      else
        conflicting_links+=("$dest")
      fi
    elif [[ -e "$dest" ]]; then
      # Classify regular files vs directories and check content differences for files
      if [[ -f "$dest" && -f "$src" ]]; then
        if diff -q "$dest" "$src" >/dev/null 2>&1; then
          if (( RELINK_IDENTICAL == 1 )); then
            identical_pairs_to_relink+=("$src::$dest")
          else
            identical_file_conflicts+=("$dest")
          fi
        else
          different_file_conflict_pairs+=("$src::$dest")
        fi
      elif [[ -d "$dest" && -d "$src" ]]; then
        dir_conflicts+=("$dest")
      else
        # Mixed types or other special files
        conflicting_files+=("$dest")
      fi
    else
      items_to_link+=("$item")
    fi
  fi
done

# Detect OS and set package file path
if [[ "$OSTYPE" == "darwin"* ]]; then
  OS_TYPE="macos"
  if [[ -n "$BREWFILE_OVERRIDE" ]]; then
    if [[ "$BREWFILE_OVERRIDE" = /* ]]; then
      PACKAGE_FILE="$BREWFILE_OVERRIDE"
    else
      PACKAGE_FILE="$(pwd)/$BREWFILE_OVERRIDE"
    fi
  else
    case "$BREW_PROFILE" in
      essentials)
        if [[ -f "$(pwd)/Brewfile.essentials" ]]; then
          PACKAGE_FILE="$(pwd)/Brewfile.essentials"
        else
          PACKAGE_FILE="$(pwd)/Brewfile"
        fi
        ;;
      full|all)
        PACKAGE_FILE="$(pwd)/Brewfile"
        ;;
      skip|none)
        PACKAGE_FILE=""
        ;;
      *)
        echo "Unknown SETUP_BREW_PROFILE: $BREW_PROFILE (use essentials, full, or skip)"
        exit 1
        ;;
    esac
  fi
elif [[ "$OSTYPE" == "linux-gnu"* ]] || [[ -f /etc/debian_version ]]; then
  OS_TYPE="ubuntu"
  PACKAGE_FILE="$(pwd)/packages.ubuntu"
else
  OS_TYPE="unknown"
  PACKAGE_FILE=""
fi

# Perform dry check for package manager (non-fatal)
if [[ "$OS_TYPE" == "macos" ]] && [[ -f "$PACKAGE_FILE" ]]; then
  set +e
  brew bundle check --no-upgrade --file="$PACKAGE_FILE" >/dev/null 2>&1
  set -e
elif [[ "$OS_TYPE" == "ubuntu" ]] && [[ -f "$PACKAGE_FILE" ]]; then
  # For Ubuntu, just check if apt is available
  if ! command -v apt-get >/dev/null 2>&1; then
    echo "Warning: apt-get not found, package installation will be skipped"
  fi
fi

# Clean up incomplete external repos before checking conflicts
if (( ${#external_to_clean[@]} > 0 )); then
  echo "Cleaning up incomplete external repos:"
  for dir in "${external_to_clean[@]}"; do
    display_path="${dir#$HOME/}"
    echo "  removing $display_path..."
    rm -rf "$dir"
  done
fi

if (( ${#conflicting_files[@]} > 0 || ${#dir_conflicts[@]} > 0 || ${#different_file_conflict_pairs[@]} > 0 || ${#conflicting_links[@]} > 0 || ${#external_conflicts[@]} > 0 || ${#identical_file_conflicts[@]} > 0 || ${#config_conflicts[@]} > 0 )); then
  echo "Refusing to proceed due to preflight problems:"
  if (( ${#identical_file_conflicts[@]} > 0 )); then
    echo "  Existing files with identical content (safe to remove and re-run):"
    printf '    %s\n' "${identical_file_conflicts[@]}"
  fi
  if (( ${#different_file_conflict_pairs[@]} > 0 )); then
    echo "  Files with content differences:"
    for pair in "${different_file_conflict_pairs[@]}"; do
      src_path="${pair%%::*}"
      dest_path="${pair##*::}"
      echo "    $dest_path"
    done
  fi
  if (( ${#dir_conflicts[@]} > 0 )); then
    echo "  Existing directories that would be overwritten:"
    printf '    %s\n' "${dir_conflicts[@]}"
  fi
  if (( ${#conflicting_files[@]} > 0 )); then
    echo "  Other conflicting paths:"
    printf '    %s\n' "${conflicting_files[@]}"
  fi
  if (( ${#conflicting_links[@]} > 0 )); then
    echo "  Existing symlinks present:"
    printf '    %s\n' "${conflicting_links[@]}"
  fi
  if (( ${#config_conflicts[@]} > 0 )); then
    echo "  Conflicting .config items (already exist):"
    printf '    %s\n' "${config_conflicts[@]}"
  fi
  if (( ${#external_conflicts[@]} > 0 )); then
    echo "  Conflicting destinations for external repos (already exist):"
    printf '    %s\n' "${external_conflicts[@]}"
  fi

  # Show unified diffs for differing files (truncate to first 500 lines for readability)
  if (( ${#different_file_conflict_pairs[@]} > 0 )); then
    echo
    echo "Diffs (destination vs repo version, first 500 lines):"
    for pair in "${different_file_conflict_pairs[@]}"; do
      src_path="${pair%%::*}"
      dest_path="${pair##*::}"
      echo "---- $dest_path ----"
      if command -v colordiff >/dev/null 2>&1; then
        colordiff -u "$dest_path" "$src_path" | sed -n '1,500p' || true
      else
        diff -u "$dest_path" "$src_path" | sed -n '1,500p' || true
      fi
      echo
    done
  fi
  echo "Abort. Resolve the above and re-run. Nothing was changed."
  exit 1
fi

# Transactional bookkeeping and rollback handler
created_links=()
created_dirs=()
installed_formulas=()
installed_casks=()
rollback_needed=0
backups_made=() # store dest::backup_path for relinked files
sudo_keepalive_pid=0

on_exit() {
  status=$?
  if (( sudo_keepalive_pid > 0 )); then
    kill "$sudo_keepalive_pid" >/dev/null 2>&1 || true
  fi
  if (( status != 0 )) && (( rollback_needed == 1 )); then
    # Avoid nounset errors if arrays are empty or unset
    set +u
    if (( ${#created_links[@]} > 0 )); then
      echo "Rolling back created symlinks..."
      for link_path in "${created_links[@]}"; do
        rm -f "$link_path" || true
      done
    fi
    if (( ${#created_dirs[@]} > 0 )); then
      echo "Rolling back created directories..."
      for dir_path in "${created_dirs[@]}"; do
        rm -rf "$dir_path" || true
      done
    fi
    if (( ${#backups_made[@]} > 0 )); then
      echo "Restoring backups for relinked files..."
      for pair in "${backups_made[@]}"; do
        restore_dest="${pair%%::*}"
        backup_path="${pair##*::}"
        rm -f "$restore_dest" 2>/dev/null || true
        mv "$backup_path" "$restore_dest" 2>/dev/null || true
      done
    fi
    # (removed) Deprecated .config rollback
    # Best-effort rollback of Homebrew installs made during this run
    if [[ ${installed_casks+set} == set ]]; then
      for pkg in "${installed_casks[@]}"; do
        brew uninstall --cask "$pkg" >/dev/null 2>&1 || true
      done
    fi
    if [[ ${installed_formulas+set} == set ]]; then
      for pkg in "${installed_formulas[@]}"; do
        brew uninstall "$pkg" >/dev/null 2>&1 || true
      done
    fi
    set -u
  fi
}
trap 'on_exit' EXIT
rollback_needed=1

# Informational: already-correct symlinks
if (( ${#already_linked_symlinks[@]} > 0 )); then
  echo "Already linked (correct symlinks present):"
  printf '  %s\n' "${already_linked_symlinks[@]}"
fi

# Informational: already-correct .config symlinks
if (( ${#config_already_linked[@]} > 0 )); then
  echo "Already linked .config items (correct symlinks present):"
  printf '  %s\n' "${config_already_linked[@]}"
fi


# Informational: external repos already present and matching manifest
if (( ${#external_present_ok[@]} > 0 )); then
  echo "External repos already present and matching manifest (reusing):"
  for spec in "${external_present_ok[@]}"; do
    dest_dir="${spec%%::*}"
    branch="${spec##*::}"
    display_path="${dest_dir#$HOME/}"
    echo "  $display_path"
    if (( UPDATE_EXTERNAL == 1 )); then
      set +e
      git -C "$dest_dir" fetch --all --prune >/dev/null 2>&1
      if [[ -n "$branch" ]]; then
        git -C "$dest_dir" checkout -q "$branch" >/dev/null 2>&1
      fi
      git -C "$dest_dir" pull --ff-only >/dev/null 2>&1
      set -e
    fi
  done
fi

# Relink identical files if requested (RELINK_IDENTICAL=1)
if (( ${#identical_pairs_to_relink[@]} > 0 )); then
  for pair in "${identical_pairs_to_relink[@]}"; do
    src_path="${pair%%::*}"
    dest_path="${pair##*::}"
    display_path="${dest_path#$HOME/}"
    backup_path="${dest_path}.setup.bak.$$"
    echo "relinking $display_path (identical)..."
    mv "$dest_path" "$backup_path"
    ln -s "$src_path" "$dest_path"
    created_links+=("$dest_path")
    backups_made+=("$dest_path::$backup_path")
  done
fi

# Create all symlinks (only runs if preflight passed)
if [[ ${items_to_link+set} == set ]] && (( ${#items_to_link[@]} > 0 )); then
  for item in "${items_to_link[@]}"; do
    src="$(pwd)/$item"
    dest="$HOME/$item"
    echo "linking $item..."
    ln -s "$src" "$dest"
    created_links+=("$dest")
  done
fi

# Create .config symlinks
if [[ ${config_items_to_link+set} == set ]] && (( ${#config_items_to_link[@]} > 0 )); then
  for config_item in "${config_items_to_link[@]}"; do
    config_src="$(pwd)/.config/$config_item"
    config_dest="$HOME/.config/$config_item"
    echo "linking .config/$config_item..."
    ln -s "$config_src" "$config_dest"
    created_links+=("$config_dest")
  done
fi


# Clone external repos, if any
if (( ${#external_to_clone[@]} > 0 )); then
  for spec in "${external_to_clone[@]}"; do
    repo="${spec%%::*}"
    rest="${spec#*::}"
    dest_repo="${rest%%::*}"
    branch="${rest##*::}"
    mkdir -p "$(dirname "$dest_repo")"
    display_path="${dest_repo#$HOME/}"

    if [[ -n "$branch" ]]; then
      echo "cloning $repo (branch $branch) -> $display_path..."
      git clone --depth 1 --branch "$branch" "$repo" "$dest_repo"
    else
      echo "cloning $repo -> $display_path..."
      git clone --depth 1 "$repo" "$dest_repo"
    fi
    created_dirs+=("$dest_repo")
  done
fi

if [[ "$OS_TYPE" == "macos" ]] && [[ -f "$PACKAGE_FILE" ]] && command -v brew >/dev/null 2>&1; then
  display_package="$PACKAGE_FILE"
  if [[ "$PACKAGE_FILE" == "$(pwd)"/* ]]; then
    display_package="${PACKAGE_FILE#$(pwd)/}"
  fi
  echo "Running brew bundle from $display_package..."
  if [[ "$BREW_SUDO" != "0" ]] && grep -qE '^[[:space:]]*cask[[:space:]]' "$PACKAGE_FILE"; then
    echo "Homebrew may prompt for your password to install casks/fonts or write to system locations."
    echo "Pre-authing sudo to avoid repeated prompts (disable with SETUP_BREW_SUDO=0)."
    set +e
    sudo -v
    sudo_status=$?
    set -e
    if (( sudo_status == 0 )); then
      ( while true; do sudo -n true; sleep 60; done ) >/dev/null 2>&1 &
      sudo_keepalive_pid=$!
    else
      echo "Warning: sudo authentication failed; you may be prompted during brew installs."
    fi
  fi
  # Snapshot pre-state
  formulas_before=( $(brew list --formula -1 2>/dev/null || true) )
  casks_before=( $(brew list --cask -1 2>/dev/null || true) )

  set +e
  bundle_output=$(brew bundle install --no-upgrade --file="$PACKAGE_FILE" 2>&1)
  bundle_status=$?
  set -e
  if (( bundle_status != 0 )); then
    echo "$bundle_output"
    # Determine what changed and schedule rollback
    formulas_after=( $(brew list --formula -1 2>/dev/null || true) )
    casks_after=( $(brew list --cask -1 2>/dev/null || true) )
    # Compute diffs (after - before)
    for pkg in "${formulas_after[@]}"; do
      present_before=0
      for b in "${formulas_before[@]}"; do
        if [[ "$b" == "$pkg" ]]; then present_before=1; break; fi
      done
      if (( present_before == 0 )); then installed_formulas+=("$pkg"); fi
    done
    for pkg in "${casks_after[@]}"; do
      present_before=0
      for b in "${casks_before[@]}"; do
        if [[ "$b" == "$pkg" ]]; then present_before=1; break; fi
      done
      if (( present_before == 0 )); then installed_casks+=("$pkg"); fi
    done
    exit $bundle_status
  fi
elif [[ "$OS_TYPE" == "ubuntu" ]] && [[ -f "$PACKAGE_FILE" ]] && command -v apt-get >/dev/null 2>&1; then
  echo "Installing packages from $PACKAGE_FILE..."
  echo "Note: This will run 'sudo apt-get update' and 'sudo apt-get install'."
  echo "Some packages may require additional setup (PPAs, cargo, etc.)."

  # Read packages from file (skip comments and empty lines)
  packages_to_install=()
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Remove leading/trailing whitespace
    line="${line#+([[:space:]])}"
    line="${line%+([[:space:]])}"
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    # Extract package name (first word, before any comment)
    pkg="${line%%[[:space:]]*}"
    pkg="${pkg%%#*}"
    [[ -n "$pkg" ]] && packages_to_install+=("$pkg")
  done < "$PACKAGE_FILE"

  if (( ${#packages_to_install[@]} > 0 )); then
    echo "Updating apt cache..."
    set +e
    sudo apt-get update -qq
    update_status=$?
    set -e

    if (( update_status != 0 )); then
      echo "Warning: apt-get update failed, but continuing with package installation..."
    fi

    # Install packages
    echo "Installing ${#packages_to_install[@]} packages..."
    set +e
    sudo apt-get install -y "${packages_to_install[@]}" >/dev/null 2>&1
    apt_status=$?
    set -e

    if (( apt_status == 0 )); then
      echo "Successfully installed all packages"
    else
      echo "Warning: Some packages may have failed to install"
      echo "Check packages.ubuntu for packages requiring manual installation"
    fi
  fi

  # Ubuntu-specific post-installation fixes
  echo "Setting up Ubuntu-specific symlinks and additional packages..."

  # Create symlinks for fd-find -> fd and batcat -> bat
  if command -v fdfind >/dev/null 2>&1 && ! command -v fd >/dev/null 2>&1; then
    echo "Creating symlink: fd -> fdfind"
    sudo ln -sf "$(command -v fdfind)" /usr/local/bin/fd
  fi

  if command -v batcat >/dev/null 2>&1 && ! command -v bat >/dev/null 2>&1; then
    echo "Creating symlink: bat -> batcat"
    sudo ln -sf "$(command -v batcat)" /usr/local/bin/bat
  fi

  # Install GitHub CLI (gh) from official repository
  if ! command -v gh >/dev/null 2>&1; then
    echo "Installing GitHub CLI (gh)..."
    set +e
    # Add GitHub CLI repository
    (curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg) >/dev/null 2>&1 &&
    sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg &&
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null &&
    sudo apt-get update -qq >/dev/null 2>&1 &&
    sudo apt-get install -y gh >/dev/null 2>&1
    gh_status=$?
    set -e
    if (( gh_status == 0 )); then
      echo "Successfully installed gh"
    else
      echo "Warning: Failed to install gh"
    fi
  fi

  # Install git-delta from GitHub releases
  if ! command -v delta >/dev/null 2>&1; then
    echo "Installing git-delta..."
    set +e
    DELTA_VERSION=$(curl -s https://api.github.com/repos/dandavison/delta/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    if [[ -n "$DELTA_VERSION" ]]; then
      DELTA_URL="https://github.com/dandavison/delta/releases/download/${DELTA_VERSION}/git-delta_${DELTA_VERSION}_$(dpkg --print-architecture).deb"
      curl -sL "$DELTA_URL" -o /tmp/git-delta.deb &&
      sudo dpkg -i /tmp/git-delta.deb >/dev/null 2>&1 &&
      rm /tmp/git-delta.deb
      delta_status=$?
      if (( delta_status == 0 )); then
        echo "Successfully installed git-delta"
      else
        echo "Warning: Failed to install git-delta"
      fi
    else
      echo "Warning: Could not determine latest git-delta version"
    fi
    set -e
  fi

  # Install lazygit from GitHub releases
  if ! command -v lazygit >/dev/null 2>&1; then
    echo "Installing lazygit..."
    set +e
    LAZYGIT_VERSION=$(curl -s https://api.github.com/repos/jesseduffield/lazygit/releases/latest | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
    if [[ -n "$LAZYGIT_VERSION" ]]; then
      curl -sL "https://github.com/jesseduffield/lazygit/releases/latest/download/lazygit_${LAZYGIT_VERSION}_Linux_x86_64.tar.gz" -o /tmp/lazygit.tar.gz &&
      tar xf /tmp/lazygit.tar.gz -C /tmp lazygit &&
      sudo install /tmp/lazygit /usr/local/bin &&
      rm /tmp/lazygit.tar.gz /tmp/lazygit
      lazygit_status=$?
      if (( lazygit_status == 0 )); then
        echo "Successfully installed lazygit"
      else
        echo "Warning: Failed to install lazygit"
      fi
    else
      echo "Warning: Could not determine latest lazygit version"
    fi
    set -e
  fi
elif [[ "$OS_TYPE" == "macos" ]] && [[ -f "$PACKAGE_FILE" ]]; then
  echo "Homebrew not found; skipping package installation."
elif [[ "$OS_TYPE" == "ubuntu" ]] && [[ -f "$PACKAGE_FILE" ]]; then
  echo "apt-get not found; skipping package installation."
elif [[ "$OS_TYPE" == "unknown" ]]; then
  echo "Unknown OS type; skipping package installation."
  echo "Detected OSTYPE: $OSTYPE"
else
  echo "No package file found for $OS_TYPE; skipping package installation."
fi

# Run private dotfiles setup if it exists
if [[ -f "$PRIVATE_REPO_PATH/setup-private" ]]; then
  echo "Running private dotfiles setup..."
  "$PRIVATE_REPO_PATH/setup-private"
fi

# Success: allow normal exit; on_exit will detect status 0 and do nothing
# Clean up backups created during relink since we succeeded
if (( ${#backups_made[@]} > 0 )); then
  for pair in "${backups_made[@]}"; do
    backup_path="${pair##*::}"
    rm -f "$backup_path" 2>/dev/null || true
  done
fi
